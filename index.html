<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>今天吃什么 - 主页</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/ripple.css">
    <link rel="stylesheet" href="css/wheel-animation.css">
    <link rel="stylesheet" href="css/card-flip.css">
    <!-- 添加GSAP库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <style>
        /* 添加Canvas样式 */
        #dishCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }

        /* 移除不再需要的样式 */
        .dish-fly-out {
            position: absolute;
            left: 50%;
            top: 50%;
            border-radius: 50%;
            overflow: hidden;
            width: 120px;
            height: 120px;
            margin-left: -60px;
            margin-top: -60px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 10;
            will-change: transform, opacity;
            backface-visibility: hidden;
            transform-style: preserve-3d;
            contain: layout style paint;
        }

        /* 添加GPU加速的类 */
        .gpu-accelerated {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            -o-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -moz-backface-visibility: hidden;
            -ms-backface-visibility: hidden;
            backface-visibility: hidden;
            -webkit-perspective: 1000;
            -moz-perspective: 1000;
            -ms-perspective: 1000;
            perspective: 1000;
        }

        /* 移除元素池样式 */
        .dish-pool {
            position: absolute;
            width: 1px;
            height: 1px;
            overflow: hidden;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>

<body class="bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100 min-h-screen font-sans">
    <!-- 设备模拟框架 -->
    <div class="flex justify-center items-center p-4 w-screen h-screen device-container">
        <!-- 卡片容器 -->
        <div class="card-container">
            <!-- 主页面模拟设备 -->
            <div id="homePage"
                class="card-face w-full h-[600px] mx-3 bg-white rounded-3xl shadow-xl overflow-hidden border-8 border-gray-100 relative">
                <!-- 顶部状态栏 -->
                <div
                    class="bg-white bg-opacity-70 backdrop-filter backdrop-blur-lg p-4 flex justify-center items-center border-b border-gray-100">
                    <div class="text-lg font-bold text-gray-800">今天吃什么</div>
                </div>

                <!-- 内容区域 -->
                <div class="w-full h-full flex flex-col items-center justify-between p-6 relative">
                    <!-- 占位区域 -->
                    <div class="flex-1 w-full flex items-center justify-center relative">
                        <canvas id="dishCanvas"></canvas>
                        <div class="w-52 h-52">

                        </div>
                    </div>

                    <!-- 底部按钮区域 -->
                    <div class="mt-6 w-full">
                        <button id="randomButton"
                            class="w-full py-4 rounded-xl bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold text-lg shadow-lg transform transition flex items-center justify-center ripple-btn"
                            onclick="randomFood()">
                            <img src="https://unpkg.com/lucide-static@latest/icons/shuffle.svg"
                                class="w-5 h-5 mr-2 text-white filter invert">
                            随机选菜
                        </button>

                        <div class="flex justify-between mt-4">
                            <button onclick="addFood()"
                                class="w-12 h-12 rounded-full bg-purple-500 backdrop-filter backdrop-blur-2xl shadow-lg flex items-center justify-center text-gray-700 transform transition ripple-btn">
                                <img src="https://unpkg.com/lucide-static@latest/icons/plus.svg"
                                    class="w-5 h-5 filter invert">
                            </button>
                            <button onclick="showFoodList()"
                                class="w-12 h-12 rounded-full bg-pink-500 backdrop-filter backdrop-blur-2xl shadow-lg flex items-center justify-center text-gray-700 transform transition ripple-btn">
                                <img src="https://unpkg.com/lucide-static@latest/icons/list.svg"
                                    class="w-5 h-5 filter invert">
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 选择结果展示页面模拟设备 -->
            <div id="resultPage"
                class="card-face w-full h-[600px] bg-white rounded-3xl shadow-xl overflow-hidden border-8 border-gray-100 relative mx-4">
                <!-- 顶部状态栏 -->
                <div
                    class="bg-white bg-opacity-70 backdrop-filter backdrop-blur-lg p-4 flex justify-center items-center border-b border-gray-100">
                    <div class="text-lg font-bold text-gray-800">选择结果</div>
                </div>

                <!-- 内容区域 -->
                <div
                    class="h-full flex flex-col items-center p-6 relative bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50">
                    <!-- 选中结果展示 -->
                    <div
                        class="w-64 h-64 rounded-full bg-white backdrop-filter backdrop-blur-lg shadow-xl flex flex-col items-center justify-center mt-3">
                        <div class="w-full h-full rounded-full overflow-hidden shadow-lg relative">
                            <img id="resultImage" class="w-full h-full object-cover">
                            <div
                                class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-40 backdrop-filter backdrop-blur-sm p-2 text-center">
                                <p id="resultName" class="text-lg font-medium text-white"></p>
                            </div>
                        </div>
                    </div>

                    <!-- 底部按钮区域 -->
                    <div class="flex justify-between mt-4 w-full">
                        <button onclick="chooseAgain()"
                            class="w-12 h-12 rounded-full bg-purple-500 backdrop-filter backdrop-blur-2xl shadow-lg flex items-center justify-center text-gray-700 transform transition ripple-btn">
                            <img src="https://unpkg.com/lucide-static@latest/icons/shuffle.svg"
                                class="w-5 h-5 text-white filter invert">
                        </button>
                        <button onclick="shareResult()"
                            class="w-12 h-12 rounded-full bg-pink-500 backdrop-filter backdrop-blur-2xl shadow-lg flex items-center justify-center text-gray-700 transform transition ripple-btn">
                            <img src="https://unpkg.com/lucide-static@latest/icons/share-2.svg"
                                class="w-5 h-5 text-white filter invert">
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="js/ripple.js"></script>
    <script src="js/wheel-animation.js"></script>
    <script>
        // 菜品数据
        const dishList = [
            { name: "红烧肉", image: "https://plus.unsplash.com/premium_photo-1664391872041-1e05862c9706?q=80&w=3787&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", desc: "经典美味，肥而不腻" },
            { name: "麻婆豆腐", image: "https://images.unsplash.com/photo-1585032226651-759b368d7246", desc: "辣味十足，下饭神器" },
            { name: "水煮鱼", image: "https://images.unsplash.com/photo-1563379926898-05f4575a45d8", desc: "麻辣鲜香，回味无穷" },
            { name: "宫保鸡丁", image: "https://images.unsplash.com/photo-1525755662778-989d0524087e", desc: "经典川菜，酸甜可口" },
            { name: "葱爆羊肉", image: "https://images.unsplash.com/photo-1544025162-d76694265947", desc: "鲜香嫩滑，营养价值高" },
            { name: "糖醋排骨", image: "https://images.unsplash.com/photo-1544025162-d76694265947", desc: "酸甜可口，色泽诱人" },
            { name: "蚝油生菜", image: "https://images.unsplash.com/photo-1543362906-acfc16c67564", desc: "清爽解腻，健康低脂" },
            { name: "东坡肉", image: "https://images.unsplash.com/photo-1555126634-323283e090fa", desc: "肥而不腻，入口即化" },
            { name: "炸酱面", image: "https://images.unsplash.com/photo-1473093295043-cdd812d0e601", desc: "经典家常面，浓香可口" },
            { name: "回锅肉", image: "https://images.unsplash.com/photo-1514326640560-7d063ef2aed5", desc: "川菜代表，香辣下饭" },
            { name: "北京烤鸭", image: "https://images.unsplash.com/photo-1518492104633-130d0cc84637", desc: "皮酥肉嫩，名扬四海" },
            { name: "酸菜鱼", image: "https://images.unsplash.com/photo-1563379926898-05f4575a45d8", desc: "酸辣开胃，鱼肉鲜嫩" },
            { name: "辣子鸡", image: "https://images.unsplash.com/photo-1525755662778-989d0524087e", desc: "麻辣香酥，香气四溢" },
            { name: "干锅牛蛙", image: "https://images.unsplash.com/photo-1548943487-a2e4e43b4853", desc: "鲜嫩多汁，香辣过瘾" },
            { name: "土豆炖牛肉", image: "https://images.unsplash.com/photo-1546549032-9571cd6b27df", desc: "浓郁软糯，温暖人心" },
            { name: "麻辣香锅", image: "https://images.unsplash.com/photo-1563379926898-05f4575a45d8", desc: "百搭食材，麻辣诱人" },
            { name: "手撕包菜", image: "https://images.unsplash.com/photo-1543362906-acfc16c67564", desc: "爽脆可口，简单美味" },
            { name: "黄焖鸡米饭", image: "https://images.unsplash.com/photo-1525755662778-989d0524087e", desc: "香浓入味，饱腹满足" },
            { name: "蛋炒饭", image: "https://images.unsplash.com/photo-1546069901-d5bfd2cbfb1f", desc: "家常经典，简单美味" },
            { name: "凉皮", image: "https://images.unsplash.com/photo-1473093295043-cdd812d0e601", desc: "劲道爽滑，酸辣可口" },
            { name: "油泼面", image: "https://images.unsplash.com/photo-1473093295043-cdd812d0e601", desc: "香辣劲道，热气腾腾" },
            { name: "豆腐脑", image: "https://images.unsplash.com/photo-1585032226651-759b368d7246", desc: "软嫩清香，早餐佳品" },
            { name: "锅包肉", image: "https://images.unsplash.com/photo-1544025162-d76694265947", desc: "酥脆爽口，东北名菜" }
        ];

        let selectedDish = null;
        let animationTimer = null;
        let dishImages = {}; // 用于存储预加载的图片
        let imagesLoaded = 0; // 跟踪已加载的图片数量
        let canvas, ctx; // Canvas相关变量
        let dishes = []; // 存储当前活跃的菜品动画对象
        let animationFrameId = null; // 动画帧ID
        let isRunningAnimation = false; // 标记动画是否正在运行

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化Canvas
            initCanvas();
            // 预加载所有图片
            preloadAllImages();
        });

        // 初始化Canvas
        function initCanvas() {
            canvas = document.getElementById('dishCanvas');
            const container = canvas.closest('.flex-1.w-full.flex');

            // 设置Canvas尺寸与容器匹配
            function resizeCanvas() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }

            // 初始调整大小
            resizeCanvas();

            // 窗口大小变化时调整Canvas大小
            window.addEventListener('resize', resizeCanvas);

            // 获取绘图上下文
            ctx = canvas.getContext('2d', { alpha: true });
        }

        // 优化的预加载所有图片功能
        function preloadAllImages() {
            const totalImages = dishList.length;

            dishList.forEach(dish => {
                // 创建缩略图尺寸，减少内存使用
                const img = new Image();
                img.crossOrigin = "Anonymous"; // 处理可能的跨域问题

                // 图片加载完成事件
                img.onload = () => {
                    // 创建缓存的图像对象
                    const cachedImg = createCachedDishImage(img, dish.name);
                    dishImages[dish.name] = {
                        original: img,
                        cached: cachedImg
                    };

                    imagesLoaded++;

                    // 所有图片加载完成后，确保按钮可用
                    if (imagesLoaded === totalImages) {
                        const randomButton = document.getElementById('randomButton');
                        randomButton.disabled = false;
                    }
                };

                // 错误处理
                img.onerror = () => {
                    console.warn(`无法加载图片: ${dish.name}`);
                    imagesLoaded++;

                    // 提供默认图像
                    const defaultImg = new Image();
                    defaultImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="12" cy="12" r="3"></circle></svg>';
                    dishImages[dish.name] = {
                        original: defaultImg,
                        cached: null
                    };

                    // 所有图片处理完成
                    if (imagesLoaded === totalImages) {
                        const randomButton = document.getElementById('randomButton');
                        randomButton.disabled = false;
                    }
                };

                // 开始加载图片
                img.src = dish.image;
            });
        }

        // 创建缓存的菜品图像
        function createCachedDishImage(img, dishName) {
            // 创建离屏Canvas用于缓存图像
            const cacheCanvas = document.createElement('canvas');
            const size = 120; // 缓存图像的尺寸
            cacheCanvas.width = size;
            cacheCanvas.height = size;
            const cacheCtx = cacheCanvas.getContext('2d');

            // 绘制圆形裁剪区域
            cacheCtx.beginPath();
            cacheCtx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            cacheCtx.closePath();
            cacheCtx.clip();

            // 计算图像缩放和位置，以适应圆形区域并保持比例
            const scale = Math.max(size / img.width, size / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (size - scaledWidth) / 2;
            const y = (size - scaledHeight) / 2;

            // 绘制图像
            cacheCtx.drawImage(img, x, y, scaledWidth, scaledHeight);

            // 添加圆形边框
            cacheCtx.strokeStyle = 'rgba(255,255,255,0.8)';
            cacheCtx.lineWidth = 2;
            cacheCtx.beginPath();
            cacheCtx.arc(size / 2, size / 2, size / 2 - 1, 0, Math.PI * 2);
            cacheCtx.stroke();

            return cacheCanvas;
        }

        // 创建单个菜品对象 - 优化动画属性
        function createDish(dish) {
            return {
                dish: dish,
                x: canvas.width / 2,
                y: canvas.height / 2,
                scale: 0,
                rotation: 0,
                opacity: 0,
                targetX: (Math.random() * 2 - 1) * (canvas.width * 0.4),
                targetY: (Math.random() * 2 - 1) * (canvas.height * 0.4),
                targetRotation: (Math.random() * 20 - 10), // 减小旋转角度范围
                stage: 0, // 0:出现, 1:回弹, 2:飞出
                startTime: performance.now(),
                stageTime: performance.now(),
                // 添加缓动函数参数
                easing: {
                    type: Math.floor(Math.random() * 3), // 随机选择缓动类型
                    power: 2 + Math.random() * 1 // 缓动强度
                }
            };
        }

        // 添加辅助函数 - 使用requestAnimationFrame模拟setTimeout
        function rafTimeout(callback, delay) {
            const startTime = performance.now();

            function checkTime(timestamp) {
                const elapsedTime = timestamp - startTime;
                if (elapsedTime >= delay) {
                    callback();
                } else {
                    rafId = requestAnimationFrame(checkTime);
                }
            }

            let rafId = requestAnimationFrame(checkTime);
            return rafId;
        }

        // 添加辅助函数 - 清除基于requestAnimationFrame的timeout
        function clearRafTimeout(rafId) {
            if (rafId) {
                cancelAnimationFrame(rafId);
            }
        }

        // 缓动函数库
        const easingFunctions = {
            // 线性
            linear: t => t,
            // 缓入
            easeIn: (t, power = 2) => Math.pow(t, power),
            // 缓出
            easeOut: (t, power = 2) => 1 - Math.pow(1 - t, power),
            // 缓入缓出
            easeInOut: (t, power = 2) => {
                return t < 0.5
                    ? Math.pow(2 * t, power) / 2
                    : 1 - Math.pow(2 * (1 - t), power) / 2;
            }
        };

        // 应用缓动函数
        function applyEasing(progress, easingType, power) {
            switch (easingType) {
                case 0: return easingFunctions.linear(progress);
                case 1: return easingFunctions.easeOut(progress, power);
                case 2: return easingFunctions.easeInOut(progress, power);
                default: return easingFunctions.easeOut(progress, power);
            }
        }

        // Canvas动画循环 - 优化性能
        function animateCanvas(timestamp) {
            // 如果动画已经停止，直接返回
            if (!isRunningAnimation) return;

            // 清除Canvas - 仅在有菜品需要绘制时清除
            if (dishes.length > 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // 处理动画的菜品数量上限
            const maxProcessPerFrame = 5;
            const processCount = Math.min(dishes.length, maxProcessPerFrame);

            // 遍历当前帧要处理的菜品
            for (let i = 0; i < processCount; i++) {
                const dish = dishes[i];
                const elapsed = timestamp - dish.stageTime;

                // 根据阶段更新属性
                switch (dish.stage) {
                    case 0: // 出现阶段 - 简化并使用缓动
                        if (elapsed < 300) { // 缩短时间
                            const progress = elapsed / 300;
                            const easedProgress = applyEasing(progress, dish.easing.type, dish.easing.power);
                            dish.scale = 1.2 * easedProgress;
                            dish.rotation = -3 * easedProgress; // 减小旋转角度
                            dish.opacity = easedProgress;
                        } else {
                            dish.scale = 1.2;
                            dish.rotation = -3;
                            dish.opacity = 1;
                            dish.stage = 1;
                            dish.stageTime = timestamp;
                        }
                        break;

                    case 1: // 回弹阶段 - 简化
                        if (elapsed < 200) { // 缩短时间
                            const progress = elapsed / 200;
                            const easedProgress = applyEasing(progress, dish.easing.type, dish.easing.power);
                            dish.scale = 1.2 + (1.0 - 1.2) * easedProgress;
                            dish.rotation = -3 + 3 * easedProgress; // 减小旋转变化
                        } else {
                            dish.scale = 1.0;
                            dish.rotation = 0;
                            dish.stage = 2;
                            dish.stageTime = timestamp;
                        }
                        break;

                    case 2: // 飞出阶段
                        if (elapsed < 1500) { // 缩短时间
                            const progress = elapsed / 1500;
                            const easedProgress = applyEasing(progress, 1, 1.5); // 始终使用easeOut使动画更流畅
                            dish.x = canvas.width / 2 + dish.targetX * easedProgress;
                            dish.y = canvas.height / 2 + dish.targetY * easedProgress;
                            dish.scale = 1.0 + (0.8 - 1.0) * progress; // 缩小变化范围
                            dish.rotation = dish.targetRotation * progress; // 简化旋转
                            dish.opacity = Math.max(0, 1 - progress * 1.2);
                        } else {
                            // 完成动画，标记为移除
                            dish.completed = true;
                        }
                        break;

                    case 3: // 最终菜品特效 - 简化
                        if (elapsed < 400) { // 缩短时间
                            const progress = elapsed / 400;
                            const easedProgress = easingFunctions.easeOut(progress, 1.5);
                            dish.x = dish.x + (canvas.width / 2 - dish.x) * easedProgress;
                            dish.y = dish.y + (canvas.height / 2 - dish.y) * easedProgress;
                            dish.scale = dish.scale + (1.3 - dish.scale) * easedProgress;
                            dish.rotation = dish.rotation * (1 - easedProgress);
                            dish.opacity = Math.min(1, dish.opacity + easedProgress);
                        } else if (elapsed < 1200) {
                            const progress = (elapsed - 400) / 800;
                            dish.scale = 1.3 + (1.8 - 1.3) * progress;
                            dish.opacity = 1 - progress;
                        } else {
                            // 标记为完成
                            dish.completed = true;
                            showFinalResult();
                        }
                        break;
                }

                // 绘制菜品 - 使用优化的方法
                if (!dish.completed) {
                    drawDishOptimized(dish);
                }
            }

            // 移除已完成的菜品
            dishes = dishes.filter(dish => !dish.completed);

            // 如果还有活跃菜品，继续动画循环
            if (dishes.length > 0) {
                animationFrameId = requestAnimationFrame(animateCanvas);
            } else {
                isRunningAnimation = false;
                animationFrameId = null;
            }
        }

        // 更新绘制函数，优化模糊效果
        function drawDishOptimized(dish) {
            // 跳过不可见的菜品
            if (dish.opacity <= 0) return;

            // 保存当前上下文状态
            ctx.save();

            // 设置模糊效果 - 改进为从模糊到清晰的自然过渡
            let blurAmount = 0;

            if (dish.stage === 0) {
                // 刚出现时模糊值从3px减少到1px
                const elapsed = performance.now() - dish.stageTime;
                const progress = Math.min(1.0, elapsed / 300);
                blurAmount = 3 - (3 - 1) * progress;
            } else if (dish.stage === 1) {
                // 从1px线性减少到0px (完全清晰)
                const elapsed = performance.now() - dish.stageTime;
                const progress = Math.min(1.0, elapsed / 200);
                blurAmount = 1 - progress;
            } else if (dish.stage === 2) {
                // 飞出时保持轻微模糊，从0px到1px
                const elapsed = performance.now() - dish.stageTime;
                const progress = Math.min(1.0, elapsed / 1500);
                blurAmount = progress;
            } else if (dish.stage === 3) {
                // 最终菜品特效 - 完全移除模糊效果，保持清晰
                blurAmount = 0;
            }

            // 应用模糊效果 - 仅当有模糊时才设置filter
            if (blurAmount > 0) {
                ctx.filter = `blur(${blurAmount}px)`;
            } else {
                ctx.filter = 'none';
            }

            // 设置透明度
            ctx.globalAlpha = dish.opacity;

            // 变换坐标系到菜品中心
            ctx.translate(dish.x, dish.y);
            ctx.rotate(dish.rotation * Math.PI / 180);
            ctx.scale(dish.scale, dish.scale);

            // 使用缓存的图像
            if (dishImages[dish.dish.name] && dishImages[dish.dish.name].cached) {
                const cachedImg = dishImages[dish.dish.name].cached;
                // 居中绘制
                ctx.drawImage(
                    cachedImg,
                    -cachedImg.width / 2,
                    -cachedImg.height / 2
                );
            } else {
                // 没有缓存图像时使用默认图像
                const size = 60; // 默认尺寸
                ctx.fillStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                ctx.fill();

                // 添加文本作为备用
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = '14px sans-serif';
                ctx.fillText(dish.dish.name, 0, 0);
            }

            // 恢复上下文状态
            ctx.restore();
        }

        // 随机选菜按钮点击事件 - 优化最终菜品效果
        function randomFood() {
            // 如果动画已经在运行，不再重新启动
            if (isRunningAnimation) return;

            // 添加GPU加速
            document.body.classList.add('gpu-accelerated');

            // 清除所有活跃菜品
            dishes = [];
            isRunningAnimation = true;

            // 停止当前可能正在进行的动画
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // 清除之前可能存在的定时器
            if (animationTimer) {
                clearRafTimeout(animationTimer);
                animationTimer = null;
            }

            // 禁用随机按钮，防止用户多次点击
            const randomButton = document.getElementById('randomButton');
            randomButton.disabled = true;
            randomButton.classList.add('opacity-50');

            // 重新设计：使用一个统一的时间控制器，避免多个计时器造成的不连续性
            let animationStartTime = performance.now();
            let animationTotalTime = 4000; // 总动画时间
            let lastDishTime = animationStartTime;
            let dishesToAdd = 20; // 总共会生成的菜品数量
            let addedDishes = 0;
            let finalDishSet = false; // 标记是否已设置最终菜品
            let finalDishComplete = false; // 标记最终菜品动画是否完成

            // 开始主动画循环，整合菜品生成逻辑
            function mainAnimationLoop(timestamp) {
                // 计算动画进度 (0-1)
                const elapsedTime = timestamp - animationStartTime;
                const progress = Math.min(1.0, elapsedTime / animationTotalTime);

                // 如果还有菜品需要生成且未超过总时间
                if (addedDishes < dishesToAdd && progress < 0.95) {
                    // 计算当前应该的生成间隔
                    let interval;

                    if (progress < 0.3) {
                        // 开始缓慢加速 (从800ms到150ms)
                        const startProgress = progress / 0.3;
                        interval = 800 - (800 - 150) * Math.pow(startProgress, 2.5);
                    } else if (progress < 0.7) {
                        // 中间高速阶段 (稳定在80-120ms)
                        interval = 100;
                    } else {
                        // 结束缓慢减速 (从120ms到500ms)
                        const endProgress = (progress - 0.7) / 0.25;
                        interval = 100 + (500 - 100) * Math.pow(endProgress, 2);
                    }

                    // 检查是否应该生成新菜品
                    if (timestamp - lastDishTime >= interval) {
                        // 随机选择一个菜品
                        let randomIndex = Math.floor(Math.random() * dishList.length);
                        // 避免连续显示相同菜品
                        if (addedDishes > 0 && dishes.length > 0 && dishes[dishes.length - 1].dish.name === dishList[randomIndex].name) {
                            randomIndex = (randomIndex + 1) % dishList.length;
                        }

                        const dish = dishList[randomIndex];
                        selectedDish = dish; // 保存当前展示的菜品

                        // 创建新菜品动画对象
                        dishes.push(createDish(dish));

                        // 更新状态
                        lastDishTime = timestamp;
                        addedDishes++;
                    }
                }

                // 如果动画完成且还没设置最终菜品，找出最后一个活跃菜品
                if (progress >= 1 && !finalDishSet) {
                    // 查找最后添加的菜品作为最终结果
                    if (dishes.length > 0) {
                        // 找到最后一个未完成的菜品（可能不是最后添加的）
                        let lastActiveIndex = -1;
                        for (let i = dishes.length - 1; i >= 0; i--) {
                            if (!dishes[i].completed) {
                                lastActiveIndex = i;
                                break;
                            }
                        }

                        if (lastActiveIndex >= 0) {
                            // 将最后一个活跃菜品设置为最终态
                            dishes[lastActiveIndex].stage = 3;
                            dishes[lastActiveIndex].stageTime = timestamp;
                            finalDishSet = true; // 标记已设置最终菜品
                        } else {
                            // 如果没有活跃菜品，创建一个新的最终菜品
                            const finalDish = createDish(selectedDish);
                            finalDish.stage = 3;
                            finalDish.stageTime = timestamp;
                            dishes.push(finalDish);
                            finalDishSet = true;
                        }
                    } else if (selectedDish) {
                        // 如果没有菜品但有选中的菜品，创建一个新的
                        const finalDish = createDish(selectedDish);
                        finalDish.stage = 3;
                        finalDish.stageTime = timestamp;
                        dishes.push(finalDish);
                        finalDishSet = true;
                    } else {
                        // 如果既没有菜品也没有选中的菜品，直接结束
                        showFinalResult();
                        finalDishSet = true;
                        finalDishComplete = true;
                    }
                }

                // 调用动画更新函数
                animateFrame(timestamp);

                // 如果动画仍在进行，继续循环
                if (isRunningAnimation) {
                    requestAnimationFrame(mainAnimationLoop);
                }
            }

            // 分离出来的帧绘制函数
            function animateFrame(timestamp) {
                // 如果动画已经停止，直接返回
                if (!isRunningAnimation) return;

                // 清除Canvas - 仅在有菜品需要绘制时清除
                if (dishes.length > 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }

                // 确保最后一个菜品总是被处理
                const maxProcessPerFrame = 10; // 增加每帧处理数量
                let processCount = Math.min(dishes.length, maxProcessPerFrame);

                // 遍历当前帧要处理的菜品
                for (let i = 0; i < processCount; i++) {
                    const dish = dishes[i];
                    const elapsed = timestamp - dish.stageTime;

                    // 根据阶段更新属性
                    switch (dish.stage) {
                        case 0: // 出现阶段 - 简化并使用缓动
                            if (elapsed < 300) { // 缩短时间
                                const progress = elapsed / 300;
                                const easedProgress = applyEasing(progress, dish.easing.type, dish.easing.power);
                                dish.scale = 1.2 * easedProgress;
                                dish.rotation = -3 * easedProgress; // 减小旋转角度
                                dish.opacity = easedProgress;
                            } else {
                                dish.scale = 1.2;
                                dish.rotation = -3;
                                dish.opacity = 1;
                                dish.stage = 1;
                                dish.stageTime = timestamp;
                            }
                            break;

                        case 1: // 回弹阶段 - 简化
                            if (elapsed < 200) { // 缩短时间
                                const progress = elapsed / 200;
                                const easedProgress = applyEasing(progress, dish.easing.type, dish.easing.power);
                                dish.scale = 1.2 + (1.0 - 1.2) * easedProgress;
                                dish.rotation = -3 + 3 * easedProgress; // 减小旋转变化
                            } else {
                                dish.scale = 1.0;
                                dish.rotation = 0;
                                dish.stage = 2;
                                dish.stageTime = timestamp;
                            }
                            break;

                        case 2: // 飞出阶段
                            if (elapsed < 1500) { // 缩短时间
                                const progress = elapsed / 1500;
                                const easedProgress = applyEasing(progress, 1, 1.5); // 始终使用easeOut使动画更流畅
                                dish.x = canvas.width / 2 + dish.targetX * easedProgress;
                                dish.y = canvas.height / 2 + dish.targetY * easedProgress;
                                dish.scale = 1.0 + (0.8 - 1.0) * progress; // 缩小变化范围
                                dish.rotation = dish.targetRotation * progress; // 简化旋转
                                dish.opacity = Math.max(0, 1 - progress * 1.2);
                            } else {
                                // 完成动画，标记为移除
                                dish.completed = true;
                            }
                            break;

                        case 3: // 最终菜品特效 - 增强最终效果
                            if (elapsed < 500) { // 第一阶段：回到中心
                                const progress = elapsed / 500;
                                const easedProgress = easingFunctions.easeOut(progress, 1.5);
                                dish.x = dish.x + (canvas.width / 2 - dish.x) * easedProgress;
                                dish.y = dish.y + (canvas.height / 2 - dish.y) * easedProgress;
                                dish.scale = dish.scale + (1.3 - dish.scale) * easedProgress;
                                dish.rotation = dish.rotation * (1 - easedProgress);
                                dish.opacity = Math.min(1, dish.opacity + easedProgress);
                            } else if (elapsed < 1500) { // 第二阶段：放大旋转效果
                                const progress = (elapsed - 500) / 1000;
                                // 使用正弦函数创建脉动效果
                                const pulse = 1.3 + 0.2 * Math.sin(progress * Math.PI * 3);
                                // 旋转也有轻微的摆动
                                const rotateWave = 5 * Math.sin(progress * Math.PI * 4);

                                dish.scale = pulse;
                                dish.rotation = rotateWave;
                                dish.opacity = 1;
                            } else if (elapsed < 2500) { // 第三阶段：逐渐停止并淡出
                                const progress = (elapsed - 1500) / 1000;
                                // 逐渐减弱振幅
                                const decayAmp = 0.2 * (1 - progress);
                                const pulse = 1.3 + decayAmp * Math.sin(progress * Math.PI * 5);
                                // 旋转也逐渐停止
                                const rotateWave = 5 * (1 - progress) * Math.sin(progress * Math.PI * 6);

                                dish.scale = pulse;
                                dish.rotation = rotateWave;
                                // 最后200ms开始淡出
                                if (progress > 0.8) {
                                    dish.opacity = 1 - (progress - 0.8) * 5; // 5倍速淡出
                                }
                            } else {
                                // 标记为完成，但不立即显示结果
                                dish.completed = true;
                                finalDishComplete = true;

                                // 确保在动画完成后短暂延迟再显示结果
                                if (!animationTimer) {
                                    animationTimer = rafTimeout(() => {
                                        showFinalResult();
                                    }, 300);
                                }
                            }
                            break;
                    }

                    // 绘制菜品 - 使用优化的方法
                    if (!dish.completed) {
                        drawDishOptimized(dish);
                    }
                }

                // 移除已完成的菜品，但保留最终菜品直到动画完全结束
                dishes = dishes.filter(dish => !dish.completed || (dish.stage === 3 && !finalDishComplete));

                // 如果没有更多菜品需要显示并且最终动画也完成了，停止动画
                if (dishes.length === 0 && finalDishComplete) {
                    isRunningAnimation = false;
                }
            }

            // 启动主动画循环
            requestAnimationFrame(mainAnimationLoop);
        }

        // 修复结果显示函数，使用正确的卡片翻转效果
        function showFinalResult() {
            // 优化DOM操作顺序和减少强制布局
            requestAnimationFrame(() => {
                // 1. 先准备结果页数据
                if (selectedDish) {
                    // 更新结果页面上的图片和名称
                    const resultImage = document.getElementById('resultImage');
                    const resultName = document.getElementById('resultName');

                    // 设置图像
                    resultImage.src = selectedDish.image;
                    resultName.textContent = selectedDish.name;

                    // 预加载图像以确保翻转前图像已加载
                    const img = new Image();
                    img.onload = () => {
                        // 图像加载完成后才触发翻转
                        requestAnimationFrame(triggerFlip);
                    };
                    img.onerror = () => {
                        console.warn("无法加载结果图像");
                        requestAnimationFrame(triggerFlip);
                    };
                    img.src = selectedDish.image;
                } else {
                    requestAnimationFrame(triggerFlip);
                }
            });

            // 触发卡片翻转效果
            function triggerFlip() {
                // 停止Canvas动画
                isRunningAnimation = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

                // 添加翻转类名
                const cardContainer = document.querySelector('.card-container');
                cardContainer.classList.add('flipped');

                // 清空Canvas内容
                clearCanvas();

                // 恢复随机按钮
                const randomButton = document.getElementById('randomButton');
                randomButton.disabled = false;
                randomButton.classList.remove('opacity-50');
            }

            // 辅助函数：清空Canvas内容
            function clearCanvas() {
                if (ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        // 添加菜品按钮点击事件
        function addFood() {
            window.location.href = 'add-food.html';
        }

        // 显示菜品列表按钮点击事件
        function showFoodList() {
            window.location.href = 'food-management.html';
        }

        // 再选一次按钮点击事件
        function chooseAgain() {
            // 翻转回主页
            const cardContainer = document.querySelector('.card-container');
            cardContainer.classList.remove('flipped');

            // 清除选中的菜品
            selectedDish = null;

            // 移除GPU加速类
            document.body.classList.remove('gpu-accelerated');
        }

        // 分享结果按钮点击事件
        function shareResult() {
            if (selectedDish) {
                // 简单的分享功能，可以根据需要扩展
                alert(`分享: 今天我要吃 ${selectedDish.name}！`);
                // 这里可以添加实际的分享逻辑
            }
        }
    </script>
</body>

</html>